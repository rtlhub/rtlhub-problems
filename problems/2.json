{
  "title": "4:1 multiplexer",
  "category": "beginner",
  "description": "### **Implement a 4:1 Multiplexer Using Two 2:1 Multiplexers**\n\nDesign a Verilog module named `mux` that implements a 4:1 multiplexer using two 2:1 multiplexers internally.\n\n#### **Module Interface**\n- Inputs: `d0`, `d1`, `d2`, `d3` (4 data inputs, 1-bit each), `s1`, `s0` (2 select inputs, 1-bit each)\n- Output: `y` (1-bit)\n\n#### **Requirements**\n- The module should be purely combinational (no registers or clocks).\n- Use two internal 2:1 multiplexers:\n- Declare internal wires for the outputs of the two 2:1 multiplexers (e.g., `mux1_out`, `mux2_out`).\n\n#### **Truth Table**\n| s1 | s0 | mux1_out | mux2_out | y  |\n|----|----|----------|----------|----|\n| 0  | 0  |    d0    |    d2    | d0 |\n| 0  | 1  |    d1    |    d3    | d1 |\n| 1  | 0  |    d0    |    d2    | d2 |\n| 1  | 1  |    d1    |    d3    | d3 |\n\nNote: The design must use internal signals `mux1_out` and `mux2_out` to ensure two 2:1 multiplexers are implemented.",
  "guide": "",
  "reference": {},
  "test": {
    "tb_top.sv": "`timescale 1ns/1ps\n\n// This is your top-level testbench module\n// DO NOT change the file name or module name\nmodule tb_top;\n    // Testbench signals\n    reg d0, d1, d2, d3, s1, s0;\n    wire y;\n    \n    // Test counters\n    integer test_count;\n    integer pass_count;\n    integer fail_count;\n\n    // Instantiate the DUT (Device Under Test)\n    mux dut (\n        .d0(d0),\n        .d1(d1),\n        .d2(d2),\n        .d3(d3),\n        .s1(s1),\n        .s0(s0),\n        .y(y)\n    );\n\n    // Waveform dump\n    // Do not remove\n    initial begin\n        $dumpfile(\"dump.fst\");\n        $dumpvars(0, tb_top);\n    end\n\n    // Test sequence\n    initial begin\n        // Initialize counters\n        test_count = 0;\n        pass_count = 0;\n        fail_count = 0;\n        \n        // Test all combinations\n        $display(\"Testing 4:1 Multiplexer\");\n        $display(\"s1 s0 | d0 d1 d2 d3 | mux1_out mux2_out | y | expected_y\");\n        \n        // s1=0, s0=0 -> y=d0\n        s1=0; s0=0; d0=0; d1=1; d2=1; d3=0; #10;\n        check_internal();\n        \n        // s1=0, s0=1 -> y=d1\n        s1=0; s0=1; d0=0; d1=1; d2=1; d3=0; #10;\n        check_internal();\n        \n        // s1=1, s0=0 -> y=d2\n        s1=1; s0=0; d0=0; d1=1; d2=0; d3=0; #10;\n        check_internal();\n        \n        // s1=1, s0=1 -> y=d3\n        s1=1; s0=1; d0=0; d1=1; d2=1; d3=1; #10;\n        check_internal();\n        \n        // Additional test with different data\n        s1=0; s0=0; d0=1; d1=0; d2=0; d3=1; #10;\n        check_internal();\n        \n        s1=1; s0=1; d0=1; d1=0; d2=1; d3=1; #10;\n        check_internal();\n        \n        // Final summary\n        $display(\"\\n============================================================\");\n        $display(\"Test Summary:\");\n        $display(\"Total Tests: %0d\", test_count);\n        $display(\"Passed: %0d\", pass_count);\n        $display(\"Failed: %0d\", fail_count);\n        \n        if (fail_count == 0) begin\n            $display(\"\\n*** ALL TESTS PASSED ***\");\n        end else begin\n            $display(\"\\n*** SOME TESTS FAILED ***\");\n        end\n        $display(\"============================================================\");\n        \n        // End simulation\n        $display(\"\\nTest completed\");\n        $finish;\n    end\n\n    task check_internal;\n        reg expected_mux1_out, expected_mux2_out, expected_y;\n        integer errors;\n        begin\n            errors = 0;\n            expected_mux1_out = s0 ? d1 : d0;\n            expected_mux2_out = s0 ? d3 : d2;\n            expected_y = s1 ? expected_mux2_out : expected_mux1_out;\n            \n            $display(\"%b  %b  | %b  %b  %b  %b  |    %b        %b     | %b |     %b\", \n                     s1, s0, d0, d1, d2, d3, dut.mux1_out, dut.mux2_out, y, expected_y);\n            \n            if (dut.mux1_out !== expected_mux1_out) begin\n                $display(\"ERROR: Internal mux1_out mismatch: expected %b, got %b\", expected_mux1_out, dut.mux1_out);\n                errors = errors + 1;\n            end\n            if (dut.mux2_out !== expected_mux2_out) begin\n                $display(\"ERROR: Internal mux2_out mismatch: expected %b, got %b\", expected_mux2_out, dut.mux2_out);\n                errors = errors + 1;\n            end\n            if (y !== expected_y) begin\n                $display(\"ERROR: Output y mismatch: expected %b, got %b\", expected_y, y);\n                errors = errors + 1;\n            end\n            \n            if (errors == 0) begin\n                pass_count = pass_count + 1;\n            end else begin\n                fail_count = fail_count + 1;\n            end\n            test_count = test_count + 1;\n        end\n    endtask\n\nendmodule"
  },
  "solution": {
    "mux.sv": "module mux (\n    input d0,d1,d2,d3,s1,s0,\n    output logic y\n);\n\nlogic mux1_out, mux2_out;\n\nalways_comb begin\n    mux1_out = s0 ? d1 : d0;\n    mux2_out = s0 ? d3 : d2;\n    y = s1? mux2_out:mux1_out;\nend\nendmodule"
  },
  "tools": {
    "simulation": "icarus",
    "coverage": null,
    "lint": null,
    "synthesis": null
  }
}