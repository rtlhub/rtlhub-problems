{
  "title": "full adder",
  "category": "beginner",
  "description": "### **Implement a Full Adder Using Two Half Adders**\n\nDesign a Verilog module named `adder` that implements a full adder using two half adders internally.\n\n#### **Module Interface**\n- Inputs: `a`, `b` (addends, 1-bit each), `cin` (carry-in, 1-bit)\n- Outputs: `sum` (1-bit), `cout` (carry-out, 1-bit)\n\n#### **Requirements**\n- The module should be purely combinational (no registers or clocks).\n- Use two internal half adders.\n- Declare internal wires with the following names: `ha1_sum`, `ha1_cout`, `ha2_sum`, `ha2_cout`.\n\n```\n        ┌────────┐           ┌────────┐\n    a ──┤        │───────────┤        │\n        │  HA1   │           │        │──── ···\n    b ──┤        │── ···     │  HA2   │\n        └────────┘           │        │\n                             │        │──── ···\n  cin ───────────────────────┤        │\n                             └────────┘\n```\n\nNote: The design must use the specified internal signals `ha1_sum`, `ha1_cout`, `ha2_sum`, `ha2_cout` to ensure two half adders are implemented.\n\n\n",
  "guide": "",
  "reference": {},
  "test": {
    "tb_top.sv": "`timescale 1ns/1ps\n\n// This is your top-level testbench module\n// DO NOT change the file name or module name\nmodule tb_top;\n    // Testbench signals\n    reg a, b, cin;\n    wire sum, cout;\n    \n    // Test counters\n    integer test_count;\n    integer pass_count;\n    integer fail_count;\n\n    // Instantiate the DUT (Device Under Test)\n    adder dut (\n        .a(a),\n        .b(b),\n        .cin(cin),\n        .sum(sum),\n        .cout(cout)\n    );\n\n    // Waveform dump\n    // Do not remove\n    initial begin\n        $dumpfile(\"dump.fst\");\n        $dumpvars(0, tb_top);\n    end\n\n    // Test sequence\n    initial begin\n        // Initialize counters\n        test_count = 0;\n        pass_count = 0;\n        fail_count = 0;\n        \n        // Test all combinations\n        $display(\"Testing Full Adder\");\n        $display(\"a b cin | ha1_sum ha1_cout ha2_sum ha2_cout | sum cout | expected_sum expected_cout\");\n        \n        // Test all 8 combinations\n        a=0; b=0; cin=0; #10; check_internal();\n        a=0; b=0; cin=1; #10; check_internal();\n        a=0; b=1; cin=0; #10; check_internal();\n        a=0; b=1; cin=1; #10; check_internal();\n        a=1; b=0; cin=0; #10; check_internal();\n        a=1; b=0; cin=1; #10; check_internal();\n        a=1; b=1; cin=0; #10; check_internal();\n        a=1; b=1; cin=1; #10; check_internal();\n        \n        // Final summary\n        $display(\"\\n============================================================\");\n        $display(\"Test Summary:\");\n        $display(\"Total Tests: %0d\", test_count);\n        $display(\"Passed: %0d\", pass_count);\n        $display(\"Failed: %0d\", fail_count);\n        \n        if (fail_count == 0) begin\n            $display(\"\\n*** ALL TESTS PASSED ***\");\n        end else begin\n            $display(\"\\n*** SOME TESTS FAILED ***\");\n        end\n        $display(\"============================================================\");\n        \n        // End simulation\n        $display(\"\\nTest completed\");\n        $finish;\n    end\n\n    task check_internal;\n        reg expected_ha1_sum, expected_ha1_cout, expected_ha2_sum, expected_ha2_cout, expected_sum, expected_cout;\n        integer errors;\n        begin\n            errors = 0;\n            expected_ha1_sum = a ^ b;\n            expected_ha1_cout = a & b;\n            expected_ha2_sum = expected_ha1_sum ^ cin;\n            expected_ha2_cout = expected_ha1_sum & cin;\n            expected_sum = expected_ha2_sum;\n            expected_cout = expected_ha1_cout | expected_ha2_cout;\n            \n            $display(\"%b %b  %b  |   %b       %b        %b       %b      |  %b   %b   |      %b          %b\", \n                     a, b, cin, dut.ha1_sum, dut.ha1_cout, dut.ha2_sum, dut.ha2_cout, sum, cout, expected_sum, expected_cout);\n            \n            if (dut.ha1_sum !== expected_ha1_sum) begin\n                $display(\"ERROR: Internal ha1_sum mismatch: expected %b, got %b\", expected_ha1_sum, dut.ha1_sum);\n                errors = errors + 1;\n            end\n            if (dut.ha1_cout !== expected_ha1_cout) begin\n                $display(\"ERROR: Internal ha1_cout mismatch: expected %b, got %b\", expected_ha1_cout, dut.ha1_cout);\n                errors = errors + 1;\n            end\n            if (dut.ha2_sum !== expected_ha2_sum) begin\n                $display(\"ERROR: Internal ha2_sum mismatch: expected %b, got %b\", expected_ha2_sum, dut.ha2_sum);\n                errors = errors + 1;\n            end\n            if (dut.ha2_cout !== expected_ha2_cout) begin\n                $display(\"ERROR: Internal ha2_cout mismatch: expected %b, got %b\", expected_ha2_cout, dut.ha2_cout);\n                errors = errors + 1;\n            end\n            if (sum !== expected_sum) begin\n                $display(\"ERROR: Output sum mismatch: expected %b, got %b\", expected_sum, sum);\n                errors = errors + 1;\n            end\n            if (cout !== expected_cout) begin\n                $display(\"ERROR: Output cout mismatch: expected %b, got %b\", expected_cout, cout);\n                errors = errors + 1;\n            end\n            \n            if (errors == 0) begin\n                pass_count = pass_count + 1;\n            end else begin\n                fail_count = fail_count + 1;\n            end\n            test_count = test_count + 1;\n        end\n    endtask\n\nendmodule"
  },
  "solution": {
    "adder.sv": "module adder (\n    input a, b, cin,\n    output logic sum, cout\n);\n\nlogic ha1_sum, ha1_cout, ha2_sum, ha2_cout;\nassign {ha1_cout,ha1_sum} = a+b;\nassign {ha2_cout,ha2_sum} = cin+ha1_sum;\n\nassign sum = ha2_sum;\nassign cout = ha1_cout | ha2_cout;\n\nendmodule"
  },
  "tools": {
    "simulation": "icarus",
    "coverage": null,
    "lint": null,
    "synthesis": null
  }
}